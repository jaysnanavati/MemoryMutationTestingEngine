        -:    0:Source:pseudolru.c
        -:    0:Programs:2
        -:    1:
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <assert.h>
        -:    5:
        -:    6:#include <stdio.h>
        -:    7:
        -:    8:#include "pseudolru.h"
        -:    9:
        -:   10:#define LEFT 0
        -:   11:#define RIGHT 1
        -:   12:
        -:   13:typedef struct tree_node_s tree_node_t;
        -:   14:
        -:   15:struct tree_node_s
        -:   16:{
        -:   17:    tree_node_t *left, *right;
        -:   18:    void *key, *value;
        -:   19:    int bit;
        -:   20:};
        -:   21:
       16:   22:pseudolru_t *pseudolru_new(
        -:   23:    int (*cmp) (const void *,
        -:   24:                const void *)
        -:   25:)
        -:   26:{
       16:   27:    pseudolru_t *me = calloc(1,sizeof(pseudolru_t));
        -:   28:    memset(me, 0, sizeof(pseudolru_t));
       16:   29:    me->cmp = cmp;
       16:   30:    return me;
        -:   31:}
        -:   32:
       86:   33:static void __free_node(
        -:   34:    tree_node_t * node
        -:   35:)
        -:   36:{
       86:   37:    if (node)
        -:   38:    {
       35:   39:        __free_node(node->left);
       35:   40:        __free_node(node->right);
       35:   41:        free(node);
        -:   42:    }
       86:   43:}
        -:   44:
       16:   45:void pseudolru_free(
        -:   46:    pseudolru_t * me
        -:   47:)
        -:   48:{
       16:   49:    __free_node(me->root);
       16:   50:    free(me);
       16:   51:}
        -:   52:
        -:   53:static tree_node_t *__init_node(
        -:   54:    void *key,
        -:   55:    void *value
        -:   56:)
        -:   57:{
       39:   58:    tree_node_t *new = malloc(sizeof(tree_node_t));
       39:   59:    new->left = new->right = NULL;
       39:   60:    new->key = key;
       39:   61:    new->value = value;
       39:   62:    new->bit = 0;
        -:   63:    return new;
        -:   64:}
        -:   65:
       34:   66:static void __rotate_right(
        -:   67:    tree_node_t ** pa
        -:   68:)
        -:   69:{
       34:   70:    tree_node_t *child = (*pa)->left;
       34:   71:    assert(child);
       34:   72:    (*pa)->left = child->right;
       34:   73:    child->right = *pa;
       34:   74:    *pa = child;
       34:   75:}
        -:   76:
       19:   77:static void __rotate_left(
        -:   78:    tree_node_t ** pa
        -:   79:)
        -:   80:{
       19:   81:    tree_node_t *child = (*pa)->right;
       19:   82:    assert(child);
       19:   83:    (*pa)->right = child->left;
       19:   84:    child->left = *pa;
       19:   85:    *pa = child;
       19:   86:}
        -:   87:
        -:   88:/**
        -:   89: * bring this value to the top
        -:   90: * */
      132:   91:static tree_node_t *__splay(
        -:   92:    pseudolru_t * me,
        -:   93:    int update_if_not_found,
        -:   94:    tree_node_t ** gpa,
        -:   95:    tree_node_t ** pa,
        -:   96:    tree_node_t ** child,
        -:   97:    const void *key
        -:   98:)
        -:   99:{
        -:  100:    /* if no child, we have reached the bottom of the tree with no success: exit */
      132:  101:    if (!(*child))
        -:  102:    {
        -:  103:        return NULL;
        -:  104:    }
        -:  105:
      101:  106:    assert(me->cmp);
        -:  107:
      101:  108:    int cmp = me->cmp((*child)->key, key);
        -:  109:
        -:  110:    tree_node_t *next;
        -:  111:
      101:  112:    if (cmp == 0)
        -:  113:    {
        -:  114:        /* we have found the item */
       16:  115:        next = *child;
        -:  116:    }
       85:  117:    else if (cmp > 0)
        -:  118:    {
       47:  119:        (*child)->bit = RIGHT;
       47:  120:        next =
       47:  121:            __splay(me, update_if_not_found, pa, child, &(*child)->left, key);
        -:  122:    }
        -:  123:    else
        -:  124:    {
       38:  125:        (*child)->bit = LEFT;
       38:  126:        next =
       38:  127:            __splay(me, update_if_not_found, pa, child, &(*child)->right, key);
        -:  128:    }
        -:  129:
      101:  130:    if (!next)
        -:  131:    {
       32:  132:        if (update_if_not_found)
        -:  133:        {
       27:  134:            next = *child;
        -:  135:        }
        -:  136:        else
        -:  137:        {
        -:  138:            return NULL;
        -:  139:        }
        -:  140:    }
        -:  141:    else
        -:  142:    {
       69:  143:        if (next != *child)
        -:  144:            return next;
        -:  145:    }
        -:  146:
       80:  147:    if (!pa)
        -:  148:        return next;
        -:  149:
       37:  150:    if (!gpa)
        -:  151:    {
        -:  152:        /* zig left */
       21:  153:        if ((*pa)->left == next)
        -:  154:        {
        9:  155:            __rotate_right(pa);
        -:  156:        }
        -:  157:        /* zig right */
        -:  158:        else
        -:  159:        {
       12:  160:            __rotate_left(pa);
        -:  161:        }
       21:  162:        return next;
        -:  163:    }
        -:  164:
       16:  165:    assert(gpa);
        -:  166:
        -:  167:    /* zig zig left */
       16:  168:    if ((*pa)->left == next && (*gpa)->left == *pa)
        -:  169:    {
       11:  170:        __rotate_right(pa);
       11:  171:        __rotate_right(gpa);
        -:  172:    }
        -:  173:    /* zig zig right */
        5:  174:    else if ((*pa)->right == next && (*gpa)->right == *pa)
        -:  175:    {
        2:  176:        __rotate_left(pa);
        2:  177:        __rotate_left(gpa);
        -:  178:    }
        -:  179:    /* zig zag right */
        3:  180:    else if ((*pa)->right == next && (*gpa)->left == *pa)
        -:  181:    {
        -:  182:        // TODO: test cases don't cover this conditional
    #####:  183:        __rotate_left(pa);
    #####:  184:        __rotate_right(gpa);
        -:  185:    }
        -:  186:    /* zig zag left */
        3:  187:    else if ((*pa)->left == next && (*gpa)->right == *pa)
        -:  188:    {
        3:  189:        __rotate_right(pa);
        3:  190:        __rotate_left(gpa);
        -:  191:    }
        -:  192:
       16:  193:    return next;
        -:  194:}
        -:  195:
        2:  196:int pseudolru_is_empty(
        -:  197:    pseudolru_t * me
        -:  198:)
        -:  199:{
        2:  200:    return NULL == me->root;
        -:  201:}
        -:  202:
       18:  203:void *pseudolru_get(
        -:  204:    pseudolru_t * me,
        -:  205:    const void *key
        -:  206:)
        -:  207:{
        -:  208:    tree_node_t *node;
        -:  209:
       18:  210:    node = __splay(me, 0, NULL, NULL, (tree_node_t **) & me->root, key);
       18:  211:    return node ? node->value : NULL;
        -:  212:}
        -:  213:
        5:  214:void *pseudolru_remove(
        -:  215:    pseudolru_t * me,
        -:  216:    const void *key
        -:  217:)
        -:  218:{
        -:  219:
        5:  220:    if (!pseudolru_get(me, key))
        -:  221:    {
        -:  222:        return NULL;
        -:  223:    }
        -:  224:
        4:  225:    tree_node_t *root = me->root;
        4:  226:    void *val = root->value;
        -:  227:
        4:  228:    assert(0 < me->count);
        4:  229:    assert(root->key == key);
        -:  230:
        -:  231:    /* get left side's most higest value node */
        4:  232:    if (root->left)
        -:  233:    {
        -:  234:        tree_node_t *prev = root;
        -:  235:        tree_node_t *left_highest = root->left;
        -:  236:
        -:  237:        /*  get furtherest right - since this is 'higher' */
        4:  238:        while (left_highest->right)
        -:  239:        {
        -:  240:            prev = left_highest;
        -:  241:            left_highest = left_highest->right;
        -:  242:        }
        -:  243:
        -:  244:        /* do the swap */
        2:  245:        if (prev != root)
        -:  246:        {
        2:  247:            prev->right = left_highest->left;
        2:  248:            left_highest->left = root->left;
        -:  249:        }
        2:  250:        me->root = left_highest;
        2:  251:        left_highest->right = root->right;
        -:  252:    }
        -:  253:    /* there is no left */
        -:  254:    else
        -:  255:    {
        2:  256:        assert(root);
        2:  257:        me->root = root->right;
        -:  258:    }
        -:  259:
        4:  260:    me->count--;
        -:  261:
        4:  262:    free(root);
        -:  263:
        4:  264:    return val;
        -:  265:}
        -:  266:
        -:  267:static tree_node_t *__get_lru(
        -:  268:    tree_node_t * node
        -:  269:)
        -:  270:{
        6:  271:    if (!node)
        -:  272:    {
        -:  273:        return NULL;
        -:  274:    }
        -:  275:
        6:  276:    if (node->bit == RIGHT)
        -:  277:    {
        2:  278:        if (node->right)
        -:  279:        {
        -:  280:            return __get_lru(node->right);
        -:  281:        }
        -:  282:    }
        4:  283:    else if (node->bit == LEFT)
        -:  284:    {
        4:  285:        if (node->left)
        -:  286:        {
        -:  287:            return __get_lru(node->left);
        -:  288:        }
        -:  289:    }
        -:  290:
        -:  291:    return node;
        -:  292:}
        -:  293:
        2:  294:void *pseudolru_pop_lru(
        -:  295:    pseudolru_t * dt
        -:  296:)
        -:  297:{
        4:  298:    return pseudolru_remove(dt, __get_lru(dt->root)->key);
        -:  299:}
        -:  300:
        -:  301:#if 0
        -:  302:static int __count(
        -:  303:    tree_node_t * node
        -:  304:)
        -:  305:{
        -:  306:    if (!node)
        -:  307:    {
        -:  308:        return 0;
        -:  309:    }
        -:  310:    else
        -:  311:    {
        -:  312:        return 1 + __count(node->left) + __count(node->right);
        -:  313:    }
        -:  314:}
        -:  315:#endif
        -:  316:
        8:  317:int pseudolru_count(
        -:  318:    pseudolru_t * me
        -:  319:)
        -:  320:{
        -:  321:#if 1
        8:  322:    return me->count;
        -:  323:#else
        -:  324:    return __count(me->root);
        -:  325:#endif
        -:  326:}
        -:  327:
        4:  328:void *pseudolru_peek(
        -:  329:    pseudolru_t * me
        -:  330:)
        -:  331:{
        4:  332:    return me->root ? ((tree_node_t *) me->root)->value : NULL;
        -:  333:}
        -:  334:
       41:  335:void pseudolru_put(
        -:  336:    pseudolru_t * me,
        -:  337:    void *key,
        -:  338:    void *value
        -:  339:)
        -:  340:{
        -:  341:    tree_node_t *new;
        -:  342:
       41:  343:    if (!me->root)
        -:  344:    {
       12:  345:        me->root = __init_node(key, value);
       12:  346:        me->count++;
       12:  347:        goto exit;
        -:  348:    }
        -:  349:
       29:  350:    new = __splay(me, 1, NULL, NULL, (tree_node_t **) & me->root, key);
        -:  351:
       29:  352:    int cmp = me->cmp(((tree_node_t *) me->root)->key, key);
        -:  353:
       29:  354:    if (cmp != 0)
        -:  355:    {
       27:  356:        new = __init_node(key, value);
        -:  357:
       27:  358:        if (0 < cmp)
        -:  359:        {
       12:  360:            new->right = me->root;
       12:  361:            new->left = new->right->left;
       12:  362:            new->right->left = NULL;
        -:  363:        }
        -:  364:        else
        -:  365:        {
       15:  366:            new->left = me->root;
       15:  367:            new->right = new->left->right;
       15:  368:            new->left->right = NULL;
        -:  369:        }
        -:  370:
       27:  371:        me->count++;
        -:  372:    }
        -:  373:
       29:  374:    me->root = new;
        -:  375:
        -:  376:  exit:
       41:  377:    return;
        -:  378:}
        -:  379:
        -:  380:#if 0
        -:  381:static void __traverse(
        -:  382:    tree_node_t * node,
        -:  383:    int d
        -:  384:)
        -:  385:{
        -:  386:    if (!node)
        -:  387:        return;
        -:  388:
        -:  389:    int ii;
        -:  390:
        -:  391:    for (ii = 0; ii < d; ii++)
        -:  392:        printf(" ");
        -:  393:    printf("%lx\n", (unsigned long int) (void *) node);
        -:  394:
        -:  395:    if (node->right)
        -:  396:    {
        -:  397:        for (ii = 0; ii < d; ii++)
        -:  398:            printf(" ");
        -:  399:        printf(" R");
        -:  400:        traverse(node->right, d + 1);
        -:  401:    }
        -:  402:    if (node->left)
        -:  403:    {
        -:  404:        for (ii = 0; ii < d; ii++)
        -:  405:            printf(" ");
        -:  406:        printf(" L");
        -:  407:        traverse(node->left, d + 1);
        -:  408:    }
        -:  409:}
        -:  410:#endif
