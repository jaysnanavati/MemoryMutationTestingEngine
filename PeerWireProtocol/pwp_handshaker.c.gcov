        -:    0:Source:pwp_handshaker.c
        -:    0:Programs:2
        -:    1:
        -:    2:/**
        -:    3: * Copyright (c) 2011, Willem-Hendrik Thiart
        -:    4: * Use of this source code is governed by a BSD-style license that can be
        -:    5: * found in the LICENSE file. 
        -:    6: *
        -:    7: * @file
        -:    8: * @brief Manage a connection with a peer
        -:    9: * @author  Willem Thiart himself@willemthiart.com
        -:   10: * @version 0.1
        -:   11: */
        -:   12:
        -:   13:#include <assert.h>
        -:   14:#include <stdlib.h>
        -:   15:#include <stdio.h>
        -:   16:#include <string.h>
        -:   17:#include <stdint.h>
        -:   18:
        -:   19:#include "bitfield.h"
        -:   20:#include "pwp_connection.h"
        -:   21:#include "pwp_handshaker.h"
        -:   22:#include "pwp_local.h"
        -:   23:#include "bitstream.h"
        -:   24:
        -:   25:typedef struct {
        -:   26:    pwp_handshake_t hs;
        -:   27:    unsigned int bytes_read;
        -:   28:
        -:   29:    unsigned char* cur;
        -:   30:    unsigned char* curr_value;
        -:   31:
        -:   32:    /* expected infohash */
        -:   33:    unsigned char* expected_ih;
        -:   34:
        -:   35:    /* my peer id */
        -:   36:    unsigned char* my_pi;
        -:   37:
        -:   38:    /* 1 is handshake is done; 0 otherwise */
        -:   39://    int status;
        -:   40:} pwp_handshaker_t;
        -:   41:
function pwp_send_handshake called 0 returned 0% blocks executed 0%
    #####:   42:int pwp_send_handshake(
        -:   43:        void* callee,
        -:   44:        void* udata,
        -:   45:        int (*send)(void *callee, const void *udata, const void *send_data, const int len),
        -:   46:        char* expected_ih,
        -:   47:        char* my_pi)
        -:   48:{
    #####:   49:    char buf[1024], *protocol_name = PROTOCOL_NAME, *ptr;
        -:   50:    int size, ii;
        -:   51:
    #####:   52:    assert(NULL != expected_ih);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   53:    assert(NULL != my_pi);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   54:
        -:   55://    sprintf(buf, "%c%s" PWP_PC_HANDSHAKE_RESERVERD "%s%s",
        -:   56://            strlen(protocol_name), protocol_name, expected_ih, peerid);
        -:   57:
    #####:   58:    ptr = buf;
        -:   59:
        -:   60:    /* protocol name length */
    #####:   61:    bitstream_write_ubyte((unsigned char**)&ptr, strlen(protocol_name));
call    0 never executed
        -:   62:
        -:   63:    /* protocol name */
    #####:   64:    bitstream_write_string((unsigned char**)&ptr, protocol_name, strlen(protocol_name));
call    0 never executed
        -:   65:
        -:   66:    /* reserved characters */
    #####:   67:    for (ii=0;ii<8;ii++)
branch  0 never executed
branch  1 never executed
    #####:   68:        bitstream_write_ubyte((unsigned char**)&ptr, 0);
call    0 never executed
        -:   69:
        -:   70:    /* infohash */
    #####:   71:    bitstream_write_string((unsigned char**)&ptr, expected_ih, 20);
call    0 never executed
        -:   72:
        -:   73:    /* peerid */
    #####:   74:    bitstream_write_string((unsigned char**)&ptr, my_pi, 20);
call    0 never executed
        -:   75:
        -:   76:    /* calculate total handshake size */
    #####:   77:    size = 1 + strlen(protocol_name) + 8 + 20 + 20;
        -:   78:
    #####:   79:    if (0 == send(callee, udata, buf, size))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   80:    {
        -:   81://        __log(me, "send,handshake,fail");
    #####:   82:        return 0;
        -:   83:    }
        -:   84:
    #####:   85:    return 1;
        -:   86:}
        -:   87:
function pwp_handshaker_new called 4 returned 100% blocks executed 100%
        4:   88:void* pwp_handshaker_new(unsigned char* expected_info_hash, unsigned char* mypeerid)
        -:   89:{
        -:   90:    pwp_handshaker_t* me;
        -:   91:
        4:   92:    me = calloc(1,sizeof(pwp_handshaker_t));
        4:   93:    me->expected_ih = expected_info_hash;
        4:   94:    me->my_pi = mypeerid;
        4:   95:    return me;
        -:   96:}
        -:   97:
function pwp_handshaker_release called 0 returned 0% blocks executed 0%
    #####:   98:void pwp_handshaker_release(void* hs)
        -:   99:{
    #####:  100:    pwp_handshaker_t* me = hs;
        -:  101:
    #####:  102:    free(me);
    #####:  103:}
        -:  104:
function pwp_handshaker_get_handshake called 0 returned 0% blocks executed 0%
    #####:  105:pwp_handshake_t* pwp_handshaker_get_handshake(void* me_)
        -:  106:{
    #####:  107:    pwp_handshaker_t* me = me_;
        -:  108:
        -:  109:#if 0
        -:  110:    if (me->status == 1)
        -:  111:        return &me->hs;
        -:  112:    return NULL;
        -:  113:#endif
    #####:  114:    return &me->hs;
        -:  115:}
        -:  116:
function __readbyte called 134 returned 100% blocks executed 100%
      134:  117:unsigned char __readbyte(unsigned int* bytes_read, const unsigned char **buf, unsigned int* len)
        -:  118:{
        -:  119:    unsigned char val;
        -:  120:
      134:  121:    val = **buf;
      134:  122:    *buf += 1;
      134:  123:    *bytes_read += 1;
      134:  124:    *len -= 1;
      134:  125:    return val;
        -:  126:}
        -:  127:
function pwp_handshaker_dispatch_from_buffer called 4 returned 100% blocks executed 92%
        4:  128:int pwp_handshaker_dispatch_from_buffer(void* me_, const unsigned char** buf, unsigned int* len)
        -:  129:{
        4:  130:    pwp_handshaker_t* me = me_;
        4:  131:    pwp_handshake_t* hs = &me->hs;
        -:  132:
      138:  133:    while (0 < *len)
branch  0 taken 134
branch  1 taken 0 (fallthrough)
        -:  134:    {
        -:  135:
        -:  136:    /* protcol name length
        -:  137:     * The unsigned value of the first byte indicates the length of a
        -:  138:     * character string containing the prot name. In BTP/1.0 this number
        -:  139:     * is 19. The local peer knows its own prot name and hence also the
        -:  140:     * length of it. If this length is different than the value of this
        -:  141:     * first byte, then the connection MUST be dropped. */
      134:  142:        if (me->curr_value == NULL)
branch  0 taken 4 (fallthrough)
branch  1 taken 130
        -:  143:        {
        4:  144:            hs->pn_len = __readbyte(&me->bytes_read, buf, len);
call    0 returned 4
        4:  145:            if (0 == hs->pn_len)
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        -:  146:            {
        1:  147:                printf("ERROR: invalid length\n");
call    0 returned 1
        1:  148:                return -1;
        -:  149:            }
        -:  150:
        3:  151:            me->cur = me->curr_value = hs->pn = malloc(hs->pn_len);
        -:  152:        }
        -:  153:    /* protocol name
        -:  154:    This is a character string which MUST contain the exact name of the 
        -:  155:    prot in ASCII and have the same length as given in the Name Length
        -:  156:    field. The prot name is used to identify to the local peer which
        -:  157:    version of BTP the remote peer uses. If this string is different
        -:  158:    from the local peers own prot name, then the connection is to be
        -:  159:    dropped. */
      130:  160:        else if (me->curr_value == hs->pn)
branch  0 taken 54 (fallthrough)
branch  1 taken 76
        -:  161:        {
       54:  162:            *me->cur = __readbyte(&me->bytes_read, buf, len);
call    0 returned 54
       54:  163:            me->cur++;
        -:  164:
        -:  165:            /* validate */
       54:  166:            if (me->cur - me->curr_value == hs->pn_len)
branch  0 taken 3 (fallthrough)
branch  1 taken 51
        -:  167:            {
        3:  168:                if (0 != strncmp((char*)hs->pn, PROTOCOL_NAME,
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        3:  169:                    hs->pn_len < strlen(PROTOCOL_NAME) ?
        -:  170:                        hs->pn_len : strlen(PROTOCOL_NAME)))
        -:  171:                {
        1:  172:                    printf("ERROR: incorrect protocol name\n");
call    0 returned 1
        1:  173:                    return -1;
        -:  174:                }
        -:  175:
        2:  176:                me->cur = me->curr_value = hs->reserved = malloc(8);
        -:  177:            }
        -:  178:        }
        -:  179:    /* Reserved The next 8 bytes in the string are reserved for future
        -:  180:     * extensions and should be read without interpretation. */
        -:  181:
        -:  182:    /* bep_0005, DHT: TODO
        -:  183:     * Peers supporting the DHT set the last bit of the 8-byte reserved flags
        -:  184:     *  exchanged in the BitTorrent protocol handshake. Peer receiving a
        -:  185:     *  handshake indicating the remote peer supports the DHT should send a
        -:  186:     *  PORT message. It begins with byte 0x09 and has a two byte payload
        -:  187:     *  containing the UDP port of the DHT node in network byte order. Peers
        -:  188:     *  that receive this message should attempt to ping the node on the
        -:  189:     *  received port and IP address of the remote peer. If a response to the
        -:  190:     *  ping is recieved, the node should attempt to insert the new contact
        -:  191:     *  information into their routing table according to the usual rules.  */
        -:  192:
       76:  193:        else if (me->curr_value == hs->reserved)
branch  0 taken 16 (fallthrough)
branch  1 taken 60
        -:  194:        {
       16:  195:            *(me->cur++) = __readbyte(&me->bytes_read, buf, len);
call    0 returned 16
        -:  196:
        -:  197:            /* don't know what to do with set reserved bytes */
       16:  198:            if (*(me->cur-1) != 0)
        -:  199:            {
        -:  200:                //printf("ERROR: unreserved bytes used\n");
        -:  201://                return -1;
        -:  202:            }
        -:  203:
       16:  204:            if (me->cur - me->curr_value == 8)
branch  0 taken 2 (fallthrough)
branch  1 taken 14
        -:  205:            {
        2:  206:                me->cur = me->curr_value = hs->infohash = malloc(20);
        -:  207:            }
        -:  208:        }
        -:  209:    /* Info Hash:
        -:  210:    The next 20 bytes in the string are to be interpreted as a 20-byte SHA1
        -:  211:    of the info key in the metainfo file. Presumably, since both the local
        -:  212:    and the remote peer contacted the tracker as a result of reading in the
        -:  213:    same .torrent file, the local peer will recognize the info hash value and
        -:  214:    will be able to serve the remote peer. If this is not the case, then the
        -:  215:    connection MUST be dropped. This situation can arise if the local peer
        -:  216:    decides to no longer serve the file in question for some reason. The info
        -:  217:    hash may be used to enable the client to serve multiple torrents on the
        -:  218:    same port. */
       60:  219:        else if (me->curr_value == hs->infohash)
branch  0 taken 40 (fallthrough)
branch  1 taken 20
        -:  220:        {
       40:  221:            *(me->cur++) = __readbyte(&me->bytes_read, buf, len);
call    0 returned 40
        -:  222:
        -:  223:            /* validate */
       40:  224:            if (me->cur - me->curr_value == 20)
branch  0 taken 2 (fallthrough)
branch  1 taken 38
        -:  225:            {
        -:  226:                /* check info hash matches expected */
        2:  227:                if (0 != strncmp(
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        2:  228:                            (char*)hs->infohash,
        2:  229:                            (char*)me->expected_ih, 20))
        -:  230:                {
        1:  231:                    printf("ERROR invalid infohash: '%s' vs '%s'\n",
call    0 returned 1
        -:  232:                            hs->infohash, me->expected_ih);
        1:  233:                    return -1;
        -:  234:                }
        -:  235:
        1:  236:                me->cur = me->curr_value = hs->peerid = malloc(20);
        -:  237:            }
        -:  238:        }
        -:  239:    /* Peer ID:
        -:  240:    The last 20 bytes of the handshake are to be interpreted as the
        -:  241:    self-designated name of the peer. The local peer must use this name to
        -:  242:    identify the connection hereafter. Thus, if this name matches the local
        -:  243:    peers own ID name, the connection MUST be dropped. Also, if any other
        -:  244:    peer has already identified itself to the local peer using that same peer
        -:  245:    ID, the connection MUST be dropped. */
       20:  246:        else if (me->curr_value == hs->peerid)
branch  0 taken 20 (fallthrough)
branch  1 taken 0
        -:  247:        {
       20:  248:            *(me->cur++) = __readbyte(&me->bytes_read, buf, len);
call    0 returned 20
        -:  249:
       20:  250:            if (me->cur - me->curr_value == 20)
branch  0 taken 1 (fallthrough)
branch  1 taken 19
        -:  251:            {
        -:  252:#if 0
        -:  253:                /* disconnect if peer's ID is the same as ours */
        -:  254:                if (!strncmp(peer_id,me->my_pi,20))
        -:  255:                {
        -:  256:                    __disconnect(me, "handshake: peer_id same as ours (us: %s them: %.*s)",
        -:  257:                            me->my_pi, 20, peer_id);
        -:  258:                    return 0;
        -:  259:                }
        -:  260:#endif
        -:  261://                me->status = 1;
        1:  262:                return 1;//me->bytes_read;
        -:  263:            }
        -:  264:        }
        -:  265:        else
        -:  266:        {
    #####:  267:            printf("ERROR: invalid handshake\n");
call    0 never executed
    #####:  268:            return -1;
        -:  269:        }
        -:  270:    }
        -:  271:
    #####:  272:    return 0;//me->bytes_read;
        -:  273:}
        -:  274:
