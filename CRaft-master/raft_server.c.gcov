        -:    0:Source:raft_server.c
        -:    0:Programs:4
        -:    1:
        -:    2:/**
        -:    3: * Copyright (c) 2013, Willem-Hendrik Thiart
        -:    4: * Use of this source code is governed by a BSD-style license that can be
        -:    5: * found in the LICENSE file. 
        -:    6: *
        -:    7: * @file
        -:    8: * @brief Implementation of a Raft server
        -:    9: * @author Willem Thiart himself@willemthiart.com
        -:   10: * @version 0.1
        -:   11: */
        -:   12:
        -:   13:#include <stdlib.h>
        -:   14:#include <string.h>
        -:   15:#include <stdio.h>
        -:   16:#include <assert.h>
        -:   17:
        -:   18:/* for varags */
        -:   19:#include <stdarg.h>
        -:   20:
        -:   21:#include "raft.h"
        -:   22:#include "raft_log.h"
        -:   23:#include "raft_private.h"
        -:   24:
function __log called 285 returned 100% blocks executed 100%
      285:   25:static void __log(raft_server_t *me_, void *src, const char *fmt, ...)
        -:   26:{
      285:   27:    raft_server_private_t* me = (void*)me_;
        -:   28:    char buf[1024];
        -:   29:    va_list args;
        -:   30:
      285:   31:    va_start(args, fmt);
      285:   32:    vsprintf(buf, fmt, args);
        -:   33:#if 0 /* debugging */
        -:   34:    printf("%d: %s\n", me->nodeid, buf);
        -:   35:    __FUNC_log(bto,src,buf);
        -:   36:#endif
      285:   37:}
        -:   38:
function raft_new called 63 returned 100% blocks executed 83%
       63:   39:raft_server_t* raft_new()
        -:   40:{
        -:   41:    raft_server_private_t* me;
        -:   42:
       63:   43:    if (!(me = calloc(1, sizeof(raft_server_private_t))))
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####:   44:        return NULL;
        -:   45:
       63:   46:    me->current_term = 0;
       63:   47:    me->voted_for = -1;
       63:   48:    me->current_idx = 1;
       63:   49:    me->timeout_elapsed = 0;
       63:   50:    me->request_timeout = 200;
       63:   51:    me->election_timeout = 1000;
       63:   52:    me->log = log_new();
call    0 returned 63
       63:   53:    raft_set_state((void*)me, RAFT_STATE_FOLLOWER);
call    0 returned 63
       63:   54:    return (void*)me;
        -:   55:}
        -:   56:
function raft_set_callbacks called 28 returned 100% blocks executed 100%
       28:   57:void raft_set_callbacks(raft_server_t* me_,
        -:   58:        raft_cbs_t* funcs, void* cb_ctx)
        -:   59:{
       28:   60:    raft_server_private_t* me = (void*)me_;
        -:   61:
       28:   62:    memcpy(&me->cb, funcs, sizeof(raft_cbs_t));
       28:   63:    me->cb_ctx = cb_ctx;
       28:   64:}
        -:   65:
function raft_free called 0 returned 0% blocks executed 0%
    #####:   66:void raft_free(raft_server_t* me_)
        -:   67:{
    #####:   68:    raft_server_private_t* me = (void*)me_;
        -:   69:
    #####:   70:    log_free(me->log);
call    0 never executed
    #####:   71:    free(me_);
    #####:   72:}
        -:   73:
function raft_election_start called 13 returned 100% blocks executed 100%
       13:   74:void raft_election_start(raft_server_t* me_)
        -:   75:{
       13:   76:    raft_server_private_t* me = (void*)me_;
        -:   77:
       13:   78:    __log(me_, NULL, "election starting: %d %d, term: %d",
call    0 returned 13
        -:   79:            me->election_timeout, me->timeout_elapsed, me->current_term);
        -:   80:
       13:   81:    raft_become_candidate(me_);
call    0 returned 13
       13:   82:}
        -:   83:
function raft_become_leader called 8 returned 100% blocks executed 100%
        8:   84:void raft_become_leader(raft_server_t* me_)
        -:   85:{
        8:   86:    raft_server_private_t* me = (void*)me_;
        -:   87:    int i;
        -:   88:
        8:   89:    __log(me_, NULL, "becoming leader");
call    0 returned 8
        -:   90:
        8:   91:    raft_set_state(me_,RAFT_STATE_LEADER);
call    0 returned 8
        8:   92:    me->voted_for = -1;
       28:   93:    for (i=0; i<me->num_nodes; i++)
branch  0 taken 20
branch  1 taken 8 (fallthrough)
        -:   94:    {
       20:   95:        if (me->nodeid == i) continue;
branch  0 taken 6 (fallthrough)
branch  1 taken 14
       14:   96:        raft_node_t* p = raft_get_node(me_, i);
call    0 returned 14
       14:   97:        raft_node_set_next_idx(p, raft_get_current_idx(me_)+1);
call    0 returned 14
call    1 returned 14
       14:   98:        raft_send_appendentries(me_, i);
call    0 returned 14
        -:   99:    }
        8:  100:}
        -:  101:
function raft_become_candidate called 20 returned 100% blocks executed 100%
       20:  102:void raft_become_candidate(raft_server_t* me_)
        -:  103:{
       20:  104:    raft_server_private_t* me = (void*)me_;
        -:  105:    int i;
        -:  106:
       20:  107:    __log(me_, NULL, "becoming candidate");
call    0 returned 20
        -:  108:
       20:  109:    memset(me->votes_for_me, 0, sizeof(int) * me->num_nodes);
       20:  110:    me->current_term += 1;
       20:  111:    raft_vote(me_, me->nodeid);
call    0 returned 20
       20:  112:    raft_set_state(me_, RAFT_STATE_CANDIDATE);
call    0 returned 20
        -:  113:
        -:  114:    /* we need a random factor here to prevent simultaneous candidates */
       20:  115:    me->timeout_elapsed = rand() % 500;
call    0 returned 20
        -:  116:
        -:  117:    /* request votes from nodes */
       61:  118:    for (i=0; i<me->num_nodes; i++)
branch  0 taken 41
branch  1 taken 20 (fallthrough)
        -:  119:    {
       41:  120:        if (me->nodeid == i) continue;
branch  0 taken 14 (fallthrough)
branch  1 taken 27
       27:  121:        raft_send_requestvote(me_, i);
call    0 returned 27
        -:  122:    }
       20:  123:}
        -:  124:
function raft_become_follower called 9 returned 100% blocks executed 100%
        9:  125:void raft_become_follower(raft_server_t* me_)
        -:  126:{
        9:  127:    raft_server_private_t* me = (void*)me_;
        -:  128:
        9:  129:    __log(me_, NULL, "becoming follower");
call    0 returned 9
        -:  130:
        9:  131:    raft_set_state(me_, RAFT_STATE_FOLLOWER);
call    0 returned 9
        9:  132:    me->voted_for = -1;
        9:  133:}
        -:  134:
function raft_periodic called 68 returned 100% blocks executed 94%
       68:  135:int raft_periodic(raft_server_t* me_, int msec_since_last_period)
        -:  136:{
       68:  137:    raft_server_private_t* me = (void*)me_;
        -:  138:
       68:  139:    __log(me_, NULL, "periodic elapsed time: %d", me->timeout_elapsed);
call    0 returned 68
        -:  140:
       68:  141:    switch (me->state)
branch  0 taken 51
branch  1 taken 17
        -:  142:    {
        -:  143:    case RAFT_STATE_FOLLOWER:
       51:  144:        if (me->last_applied_idx < me->commit_idx)
branch  0 taken 1 (fallthrough)
branch  1 taken 50
        -:  145:        {
        1:  146:            if (0 == raft_apply_entry(me_))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  147:                return 0;
        -:  148:        }
       51:  149:        break;
        -:  150:    }
        -:  151:
       68:  152:    me->timeout_elapsed += msec_since_last_period;
        -:  153:
       68:  154:    if (me->state == RAFT_STATE_LEADER)
branch  0 taken 7 (fallthrough)
branch  1 taken 61
        -:  155:    {
        7:  156:        if (me->request_timeout <= me->timeout_elapsed)
branch  0 taken 4 (fallthrough)
branch  1 taken 3
        -:  157:        {
        4:  158:            raft_send_appendentries_all(me_);
call    0 returned 4
        4:  159:            me->timeout_elapsed = 0;
        -:  160:        }
        -:  161:    }
        -:  162:    else
        -:  163:    {
       61:  164:        if (me->election_timeout <= me->timeout_elapsed)
branch  0 taken 12 (fallthrough)
branch  1 taken 49
        -:  165:        {
       12:  166:            raft_election_start(me_);
call    0 returned 12
        -:  167:        }
        -:  168:    }
        -:  169:
       68:  170:    return 1;
        -:  171:}
        -:  172:
function raft_get_entry_from_idx called 13 returned 100% blocks executed 100%
       13:  173:raft_entry_t* raft_get_entry_from_idx(raft_server_t* me_, int etyidx)
        -:  174:{
       13:  175:    raft_server_private_t* me = (void*)me_;
       13:  176:    return log_get_from_idx(me->log, etyidx);
call    0 returned 13
        -:  177:}
        -:  178:
function raft_recv_appendentries_response called 16 returned 100% blocks executed 70%
       16:  179:int raft_recv_appendentries_response(raft_server_t* me_,
        -:  180:        int node, msg_appendentries_response_t* r)
        -:  181:{
       16:  182:    raft_server_private_t* me = (void*)me_;
        -:  183:    raft_node_t* p;
        -:  184:
       16:  185:    __log(me_, NULL, "received appendentries response from: %d", node);
call    0 returned 16
        -:  186:
       16:  187:    p = raft_get_node(me_, node);
call    0 returned 16
        -:  188:
       16:  189:    if (1 == r->success)
branch  0 taken 16 (fallthrough)
branch  1 taken 0
        -:  190:    {
        -:  191:        int i;
        -:  192:
       32:  193:        for (i=r->first_idx; i<=r->current_idx; i++)
branch  0 taken 16
branch  1 taken 16 (fallthrough)
       16:  194:            log_mark_node_has_committed(me->log, i);
call    0 returned 16
        -:  195:
        -:  196:        while (1)
        -:  197:        {
        -:  198:            raft_entry_t* e;
        -:  199:
       18:  200:            e = log_get_from_idx(me->log, me->last_applied_idx + 1);
call    0 returned 18
        -:  201:
        -:  202:            /* majority has this */
       18:  203:            if (e && me->num_nodes / 2 <= e->num_nodes)
branch  0 taken 4 (fallthrough)
branch  1 taken 14
branch  2 taken 2 (fallthrough)
branch  3 taken 2
        -:  204:            {
        2:  205:                if (0 == raft_apply_entry(me_)) break;
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -:  206:            }
        -:  207:            else
        -:  208:            {
        -:  209:                break;
        -:  210:            }
        2:  211:        }
        -:  212:    }
        -:  213:    else
        -:  214:    {
        -:  215:        /* If AppendEntries fails because of log inconsistency:
        -:  216:           decrement nextIndex and retry (§5.3) */
    #####:  217:        assert(0 <= raft_node_get_next_idx(p));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  218:        // TODO does this have test coverage?
        -:  219:        // TODO can jump back to where node is different instead of iterating
    #####:  220:        raft_node_set_next_idx(p, raft_node_get_next_idx(p)-1);
call    0 never executed
call    1 never executed
    #####:  221:        raft_send_appendentries(me_, node);
call    0 never executed
        -:  222:    }
        -:  223:
       16:  224:    return 1;
        -:  225:}
        -:  226:
function raft_recv_appendentries called 27 returned 100% blocks executed 91%
       27:  227:int raft_recv_appendentries(
        -:  228:        raft_server_t* me_,
        -:  229:        const int node,
        -:  230:        msg_appendentries_t* ae)
        -:  231:{
        -:  232:    int i;
       27:  233:    raft_server_private_t* me = (void*)me_;
        -:  234:    msg_appendentries_response_t r;
        -:  235:
       27:  236:    me->timeout_elapsed = 0;
        -:  237:
       27:  238:    __log(me_, NULL, "received appendentries from: %d", node);
call    0 returned 27
        -:  239:
       27:  240:    r.term = me->current_term;
        -:  241:
        -:  242:    /* we've found a leader who is legitimate */
       27:  243:    if (raft_is_leader(me_) && me->current_term <= ae->term)
call    0 returned 27
branch  1 taken 3 (fallthrough)
branch  2 taken 24
branch  3 taken 3 (fallthrough)
branch  4 taken 0
        3:  244:        raft_become_follower(me_);
call    0 returned 3
        -:  245:
        -:  246:    /* 1. Reply false if term < currentTerm (§5.1) */
       27:  247:    if (ae->term < me->current_term)
branch  0 taken 1 (fallthrough)
branch  1 taken 26
        -:  248:    {
        1:  249:        __log(me_, NULL, "AE term is less than current term");
call    0 returned 1
        1:  250:        r.success = 0;
        1:  251:        goto done;
        -:  252:    }
        -:  253:
        -:  254:#if 0
        -:  255:    if (-1 != ae->prev_log_idx &&
        -:  256:         ae->prev_log_idx < raft_get_current_idx(me_))
        -:  257:    {
        -:  258:        __log(me_, NULL, "AE prev_idx is less than current idx");
        -:  259:        r.success = 0;
        -:  260:        goto done;
        -:  261:    }
        -:  262:#endif
        -:  263:
        -:  264:    /* not the first appendentries we've received */
       26:  265:    if (0 != ae->prev_log_idx)
branch  0 taken 7 (fallthrough)
branch  1 taken 19
        -:  266:    {
        -:  267:        raft_entry_t* e;
        -:  268:
        7:  269:        if ((e = raft_get_entry_from_idx(me_, ae->prev_log_idx)))
call    0 returned 7
branch  1 taken 3 (fallthrough)
branch  2 taken 4
        -:  270:        {
        -:  271:            /* 2. Reply false if log doesn’t contain an entry at prevLogIndex
        -:  272:               whose term matches prevLogTerm (§5.3) */
        3:  273:            if (e->term != ae->prev_log_term)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  274:            {
    #####:  275:                __log(me_, NULL, "AE term doesn't match prev_idx");
call    0 never executed
    #####:  276:                r.success = 0;
    #####:  277:                goto done;
        -:  278:            }
        -:  279:
        -:  280:            /* 3. If an existing entry conflicts with a new one (same index
        -:  281:            but different terms), delete the existing entry and all that
        -:  282:            follow it (§5.3) */
        -:  283:            raft_entry_t* e2;
        3:  284:            if ((e2 = raft_get_entry_from_idx(me_, ae->prev_log_idx+1)))
call    0 returned 3
branch  1 taken 2 (fallthrough)
branch  2 taken 1
        -:  285:            {
        2:  286:                log_delete(me->log, ae->prev_log_idx+1);
call    0 returned 2
        -:  287:            }
        -:  288:        }
        -:  289:        else
        -:  290:        {
        4:  291:            __log(me_, NULL, "AE no log at prev_idx");
call    0 returned 4
        4:  292:            r.success = 0;
        4:  293:            goto done;
        -:  294:            //assert(0);
        -:  295:        }
        -:  296:    }
        -:  297:
        -:  298:    /* 5. If leaderCommit > commitIndex, set commitIndex =
        -:  299:        min(leaderCommit, last log index) */
       22:  300:    if (raft_get_commit_idx(me_) < ae->leader_commit)
call    0 returned 22
branch  1 taken 9 (fallthrough)
branch  2 taken 13
        -:  301:    {
        -:  302:        raft_entry_t* e;
        -:  303:
        9:  304:        if ((e = log_peektail(me->log)))
call    0 returned 9
branch  1 taken 2 (fallthrough)
branch  2 taken 7
        -:  305:        {
        2:  306:            raft_set_commit_idx(me_, e->id < ae->leader_commit ?
call    0 returned 2
        2:  307:                    e->id : ae->leader_commit);
        2:  308:            while (1 == raft_apply_entry(me_));
call    0 returned 9
branch  1 taken 7
branch  2 taken 2 (fallthrough)
        -:  309:        }
        -:  310:    }
        -:  311:
       22:  312:    if (raft_is_candidate(me_))
call    0 returned 22
branch  1 taken 4 (fallthrough)
branch  2 taken 18
        4:  313:        raft_become_follower(me_);
call    0 returned 4
        -:  314:
       22:  315:    raft_set_current_term(me_, ae->term);
call    0 returned 22
        -:  316:
        -:  317:    
        -:  318:    
        -:  319:    /* append all entries to log */
       34:  320:    for (i=0; i<ae->n_entries; i++)
branch  0 taken 12
branch  1 taken 22 (fallthrough)
        -:  321:    {
        -:  322:        msg_entry_t* cmd;
        -:  323:        raft_entry_t* c;
        -:  324:
       12:  325:        cmd = &ae->entries[i];
        -:  326:
        -:  327:        /* TODO: replace malloc with mempoll/arena */
       12:  328:        c = malloc(sizeof(raft_entry_t));
       12:  329:        c->term = me->current_term;
       12:  330:        c->len = cmd->len;
       12:  331:        c->id = cmd->id;
       12:  332:        c->data = malloc(cmd->len);
       12:  333:        memcpy(c->data, cmd->data, cmd->len);
       12:  334:        if (0 == raft_append_entry(me_, c))
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -:  335:        {
    #####:  336:            __log(me_, NULL, "AE failure; couldn't append entry");
call    0 never executed
    #####:  337:            r.success = 0;
    #####:  338:            goto done;
        -:  339:        }
        -:  340:    }
        -:  341:
       22:  342:    r.success = 1;
       22:  343:    r.current_idx = raft_get_current_idx(me_);
call    0 returned 22
       22:  344:    r.first_idx = ae->prev_log_idx + 1;
        -:  345:
        -:  346:done:
       27:  347:    if (me->cb.send)
branch  0 taken 25 (fallthrough)
branch  1 taken 2
       25:  348:        me->cb.send(me->cb_ctx, me, node, RAFT_MSG_APPENDENTRIES_RESPONSE,
call    0 returned 25
        -:  349:                (void*)&r, sizeof(msg_appendentries_response_t));
       27:  350:    return 1;
        -:  351:}
        -:  352:
function raft_recv_requestvote called 22 returned 100% blocks executed 100%
       22:  353:int raft_recv_requestvote(raft_server_t* me_, int node, msg_requestvote_t* vr)
        -:  354:{
       22:  355:    raft_server_private_t* me = (void*)me_;
        -:  356:    msg_requestvote_response_t r;
        -:  357:
       22:  358:    if (raft_get_current_term(me_) < vr->term)
call    0 returned 22
branch  1 taken 5 (fallthrough)
branch  2 taken 17
        -:  359:    {
        5:  360:        me->voted_for = -1;
        -:  361:    }
        -:  362:
       43:  363:    if (vr->term < raft_get_current_term(me_) ||
call    0 returned 22
branch  1 taken 21 (fallthrough)
branch  2 taken 1
branch  3 taken 6 (fallthrough)
branch  4 taken 15
        -:  364:        /* we've already voted */
       27:  365:        -1 != me->voted_for ||
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        -:  366:        /* we have a more up-to-date log */
        6:  367:        vr->last_log_idx < me->current_idx)
        -:  368:    {
       18:  369:        r.vote_granted = 0;
        -:  370:    }
        -:  371:    else
        -:  372:    {
        4:  373:        raft_vote(me_,node);
call    0 returned 4
        4:  374:        r.vote_granted = 1;
        -:  375:    }
        -:  376:
       22:  377:    __log(me_, NULL, "node requested vote: %d replying: %s",
branch  0 taken 4 (fallthrough)
branch  1 taken 18
call    2 returned 22
       22:  378:            node, r.vote_granted == 1 ? "granted" : "not granted");
        -:  379:
       22:  380:    r.term = raft_get_current_term(me_);
call    0 returned 22
       22:  381:    if (me->cb.send)
branch  0 taken 22 (fallthrough)
branch  1 taken 0
       22:  382:        me->cb.send(me->cb_ctx, me, node, RAFT_MSG_REQUESTVOTE_RESPONSE,
call    0 returned 22
        -:  383:                (void*)&r, sizeof(msg_requestvote_response_t));
        -:  384:
       22:  385:    return 0;
        -:  386:}
        -:  387:
function raft_votes_is_majority called 11 returned 100% blocks executed 100%
       11:  388:int raft_votes_is_majority(const int num_nodes, const int nvotes)
        -:  389:{
        -:  390:    int half;
        -:  391:
       11:  392:    if (num_nodes < nvotes)
branch  0 taken 1 (fallthrough)
branch  1 taken 10
        1:  393:        return 0;
       10:  394:    half = num_nodes / 2;
       10:  395:    return half + 1 <= nvotes;
        -:  396:}
        -:  397:
function raft_recv_requestvote_response called 22 returned 100% blocks executed 94%
       22:  398:int raft_recv_requestvote_response(raft_server_t* me_, int node,
        -:  399:        msg_requestvote_response_t* r)
        -:  400:{
       22:  401:    raft_server_private_t* me = (void*)me_;
        -:  402:
       22:  403:    __log(me_, NULL, "node responded to requestvote: %d status: %s",
branch  0 taken 7 (fallthrough)
branch  1 taken 15
call    2 returned 22
       22:  404:            node, r->vote_granted == 1 ? "granted" : "not granted");
        -:  405:
       22:  406:    if (raft_is_leader(me_))
call    0 returned 22
branch  1 taken 1 (fallthrough)
branch  2 taken 21
        1:  407:        return 0;
        -:  408:
       21:  409:    assert(node < me->num_nodes);
branch  0 taken 0 (fallthrough)
branch  1 taken 21
call    2 never executed
        -:  410:
        -:  411://    if (r->term != raft_get_current_term(me_))
        -:  412://        return 0;
        -:  413:
       21:  414:    if (1 == r->vote_granted)
branch  0 taken 6 (fallthrough)
branch  1 taken 15
        -:  415:    {
        -:  416:        int votes;
        -:  417:
        6:  418:        me->votes_for_me[node] = 1;
        6:  419:        votes = raft_get_nvotes_for_me(me_);
call    0 returned 6
        6:  420:        if (raft_votes_is_majority(me->num_nodes, votes))
call    0 returned 6
branch  1 taken 4 (fallthrough)
branch  2 taken 2
        4:  421:            raft_become_leader(me_);
call    0 returned 4
        -:  422:    }
        -:  423:
       21:  424:    return 0;
        -:  425:}
        -:  426:
function raft_send_entry_response called 2 returned 100% blocks executed 100%
        2:  427:int raft_send_entry_response(raft_server_t* me_,
        -:  428:        int node, int etyid, int was_committed)
        -:  429:{
        2:  430:    raft_server_private_t* me = (void*)me_;
        -:  431:    msg_entry_response_t res;
        -:  432:
        2:  433:    __log(me_, NULL, "send entry response to: %d", node);
call    0 returned 2
        -:  434:
        2:  435:    res.id = etyid;
        2:  436:    res.was_committed = was_committed;
        2:  437:    if (me->cb.send)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  438:        me->cb.send(me->cb_ctx, me, node, RAFT_MSG_ENTRY_RESPONSE,
call    0 returned 1
        -:  439:                (void*)&res, sizeof(msg_entry_response_t));
        2:  440:    return 0;
        -:  441:}
        -:  442:
function raft_recv_entry called 2 returned 100% blocks executed 100%
        2:  443:int raft_recv_entry(raft_server_t* me_, int node, msg_entry_t* e)
        -:  444:{
        2:  445:    raft_server_private_t* me = (void*)me_;
        -:  446:    raft_entry_t ety;
        -:  447:    int res, i;
        -:  448:
        2:  449:    __log(me_, NULL, "received entry from: %d", node);
call    0 returned 2
        -:  450:
        2:  451:    ety.term = me->current_term;
        2:  452:    ety.id = e->id;
        2:  453:    ety.data = e->data;
        2:  454:    ety.len = e->len;
        2:  455:    res = raft_append_entry(me_, &ety);
call    0 returned 2
        2:  456:    raft_send_entry_response(me_, node, e->id, res);
call    0 returned 2
        6:  457:    for (i=0; i<me->num_nodes; i++)
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        -:  458:    {
        4:  459:        if (me->nodeid == i) continue;
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  460:        raft_send_appendentries(me_,i);
call    0 returned 2
        -:  461:    }
        2:  462:    return 0;
        -:  463:}
        -:  464:
function raft_send_requestvote called 28 returned 100% blocks executed 100%
       28:  465:int raft_send_requestvote(raft_server_t* me_, int node)
        -:  466:{
       28:  467:    raft_server_private_t* me = (void*)me_;
        -:  468:    msg_requestvote_t rv;
        -:  469:
       28:  470:    __log(me_, NULL, "sending requestvote to: %d", node);
call    0 returned 28
        -:  471:
       28:  472:    rv.term = me->current_term;
       28:  473:    rv.last_log_idx = raft_get_current_idx(me_);
call    0 returned 28
       28:  474:    if (me->cb.send)
branch  0 taken 27 (fallthrough)
branch  1 taken 1
       27:  475:        me->cb.send(me->cb_ctx, me, node, RAFT_MSG_REQUESTVOTE,
call    0 returned 27
        -:  476:                (void*)&rv, sizeof(msg_requestvote_t));
       28:  477:    return 1;
        -:  478:}
        -:  479:
function raft_append_entry called 26 returned 100% blocks executed 100%
       26:  480:int raft_append_entry(raft_server_t* me_, raft_entry_t* c)
        -:  481:{
       26:  482:    raft_server_private_t* me = (void*)me_;
        -:  483:
       26:  484:    if (1 == log_append_entry(me->log,c))
call    0 returned 26
branch  1 taken 25 (fallthrough)
branch  2 taken 1
        -:  485:    {
       25:  486:        me->current_idx += 1;
       25:  487:        return 1;
        -:  488:    }
        1:  489:    return 0;
        -:  490:}
        -:  491:
function raft_apply_entry called 16 returned 100% blocks executed 90%
       16:  492:int raft_apply_entry(raft_server_t* me_)
        -:  493:{
       16:  494:    raft_server_private_t* me = (void*)me_;
        -:  495:    raft_entry_t* e;
        -:  496:
       16:  497:    if (!(e = log_get_from_idx(me->log, me->last_applied_idx+1)))
call    0 returned 16
branch  1 taken 3 (fallthrough)
branch  2 taken 13
        3:  498:        return 0;
        -:  499:
       13:  500:    __log(me_, NULL, "applying log: %d", me->last_applied_idx);
call    0 returned 13
        -:  501:
       13:  502:    me->last_applied_idx++;
       13:  503:    if (me->commit_idx < me->last_applied_idx)
branch  0 taken 4 (fallthrough)
branch  1 taken 9
        4:  504:        me->commit_idx = me->last_applied_idx;
       13:  505:    if (me->cb.applylog)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####:  506:        me->cb.applylog(me->cb_ctx, me, e->data, e->len);
call    0 never executed
       13:  507:    return 1;
        -:  508:}
        -:  509:
function raft_send_appendentries called 30 returned 100% blocks executed 100%
       30:  510:void raft_send_appendentries(raft_server_t* me_, int node)
        -:  511:{
        -:  512:    msg_appendentries_t ae;
       30:  513:    raft_server_private_t* me = (void*)me_;
        -:  514:
       30:  515:    __log(me_, NULL, "sending appendentries to: %d", node);
call    0 returned 30
        -:  516:
       30:  517:    if (!(me->cb.send))
branch  0 taken 1 (fallthrough)
branch  1 taken 29
       31:  518:        return;
        -:  519:
       29:  520:    raft_node_t* p = raft_get_node(me_, node);
call    0 returned 29
        -:  521:
       29:  522:    ae.term = me->current_term;
       29:  523:    ae.leader_id = me->nodeid;
       29:  524:    ae.prev_log_term = raft_node_get_next_idx(p);
call    0 returned 29
        -:  525:    // TODO:
       29:  526:    ae.prev_log_idx = 0;
       29:  527:    ae.n_entries = 0;
       29:  528:    me->cb.send(me->cb_ctx, me, node, RAFT_MSG_APPENDENTRIES,
call    0 returned 29
        -:  529:            (void*)&ae, sizeof(msg_appendentries_t));
        -:  530:}
        -:  531:
function raft_send_appendentries_all called 4 returned 100% blocks executed 100%
        4:  532:void raft_send_appendentries_all(raft_server_t* me_)
        -:  533:{
        4:  534:    raft_server_private_t* me = (void*)me_;
        -:  535:    int i;
        -:  536:
       16:  537:    for (i=0; i<me->num_nodes; i++)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -:  538:    {
       12:  539:        if (me->nodeid == i) continue;
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        8:  540:        raft_send_appendentries(me_, i);
call    0 returned 8
        -:  541:    }
        4:  542:}
        -:  543:
function raft_set_configuration called 35 returned 100% blocks executed 100%
       35:  544:void raft_set_configuration(raft_server_t* me_,
        -:  545:        raft_node_configuration_t* nodes, int my_idx)
        -:  546:{
       35:  547:    raft_server_private_t* me = (void*)me_;
        -:  548:    int num_nodes;
        -:  549:
        -:  550:    /* TODO: one memory allocation only please */
      114:  551:    for (num_nodes=0; nodes->udata_address; nodes++)
branch  0 taken 79
branch  1 taken 35 (fallthrough)
        -:  552:    {
       79:  553:        num_nodes++;
       79:  554:        me->nodes = realloc(me->nodes,sizeof(raft_node_t*) * num_nodes);
       79:  555:        me->num_nodes = num_nodes;
       79:  556:        me->nodes[num_nodes-1] = raft_node_new(nodes->udata_address);
call    0 returned 79
        -:  557:    }
       35:  558:    me->votes_for_me = calloc(num_nodes, sizeof(int));
       35:  559:    me->nodeid = my_idx;
       35:  560:}
        -:  561:
function raft_get_nvotes_for_me called 13 returned 100% blocks executed 100%
       13:  562:int raft_get_nvotes_for_me(raft_server_t* me_)
        -:  563:{
       13:  564:    raft_server_private_t* me = (void*)me_;
        -:  565:    int i, votes;
        -:  566:
       52:  567:    for (i=0, votes=0; i<me->num_nodes; i++)
branch  0 taken 39
branch  1 taken 13 (fallthrough)
        -:  568:    {
       39:  569:        if (me->nodeid == i) continue;
branch  0 taken 12 (fallthrough)
branch  1 taken 27
       27:  570:        if (1 == me->votes_for_me[i])
branch  0 taken 9 (fallthrough)
branch  1 taken 18
        9:  571:            votes += 1;
        -:  572:    }
        -:  573:
       13:  574:    if (me->voted_for == me->nodeid)
branch  0 taken 8 (fallthrough)
branch  1 taken 5
        8:  575:        votes += 1;
        -:  576:
       13:  577:    return votes;
        -:  578:}
        -:  579:
function raft_vote called 31 returned 100% blocks executed 100%
       31:  580:void raft_vote(raft_server_t* me_, int node)
        -:  581:{
       31:  582:    raft_server_private_t* me = (void*)me_;
       31:  583:    me->voted_for = node;
       31:  584:}
        -:  585:
function raft_get_node called 65 returned 100% blocks executed 100%
       65:  586:raft_node_t* raft_get_node(raft_server_t *me_, int nodeid)
        -:  587:{
       65:  588:    raft_server_private_t* me = (void*)me_;
        -:  589:
       65:  590:    if (nodeid < 0 || me->num_nodes <= nodeid)
branch  0 taken 65 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 62
        3:  591:        return NULL;
       62:  592:    return me->nodes[nodeid];
        -:  593:}
        -:  594:
function raft_is_follower called 5 returned 100% blocks executed 100%
        5:  595:int raft_is_follower(raft_server_t* me_)
        -:  596:{
        5:  597:    return raft_get_state(me_) == RAFT_STATE_FOLLOWER;
call    0 returned 5
        -:  598:}
        -:  599:
function raft_is_leader called 55 returned 100% blocks executed 100%
       55:  600:int raft_is_leader(raft_server_t* me_)
        -:  601:{
       55:  602:    return raft_get_state(me_) == RAFT_STATE_LEADER;
call    0 returned 55
        -:  603:}
        -:  604:
function raft_is_candidate called 25 returned 100% blocks executed 100%
       25:  605:int raft_is_candidate(raft_server_t* me_)
        -:  606:{
       25:  607:    return raft_get_state(me_) == RAFT_STATE_CANDIDATE;
call    0 returned 25
        -:  608:}
        -:  609:
        -:  610:/*--------------------------------------------------------------79-characters-*/
